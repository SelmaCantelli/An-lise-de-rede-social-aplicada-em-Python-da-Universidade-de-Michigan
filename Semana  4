
You are currently looking at version 1.2 of this notebook. To download notebooks and datafiles, as well as get help on Jupyter notebooks in the Coursera platform, visit the Jupyter Notebook FAQ course resource.

Assignment 4
import networkx as nx
import pandas as pd
import numpy as np
import pickle
Part 1 - Random Graph Identification
For the first part of this assignment you will analyze randomly generated graphs and determine which algorithm created them.

P1_Graphs = pickle.load(open('A4_graphs','rb'))
P1_Graphs
[<networkx.classes.graph.Graph at 0x7ffb019037f0>,
 <networkx.classes.graph.Graph at 0x7ffb01903908>,
 <networkx.classes.graph.Graph at 0x7ffb01903940>,
 <networkx.classes.graph.Graph at 0x7ffb01903978>,
 <networkx.classes.graph.Graph at 0x7ffb019039b0>]

`P1_Graphs` is a list containing 5 networkx graphs. Each of these graphs were generated by one of three possible algorithms: * Preferential Attachment (`'PA'`) * Small World with low probability of rewiring (`'SW_L'`) * Small World with high probability of rewiring (`'SW_H'`)
Anaylze each of the 5 graphs and determine which of the three algorithms generated the graph.

The graph_identification function should return a list of length 5 where each element in the list is either 'PA', 'SW_L', or 'SW_H'.

def graph_identification():
    methods = []
    for G in P1_Graphs:
        degrees = G.degree()
        degree_values = sorted(set(degrees.values()))
        degree_hist = [list(degrees.values()).count(i) / float(nx.number_of_nodes(G)) for i in degree_values]
        clustering = nx.average_clustering(G)
        shortest_path = nx.average_shortest_path_length(G)
        
        if len(degree_hist)>10:
            methods.append('PA')
        elif clustering < 0.1:
            methods.append('SW_H')
        else:
            methods.append('SW_L')
    return methods
graph_identification()
['PA', 'SW_L', 'SW_L', 'PA', 'SW_H']
Part 2 - Company Emails
For the second part of this assignment you will be workking with a company's email network where each node corresponds to a person at the company, and each edge indicates that at least one email has been sent between two people.

The network also contains the node attributes Department and ManagementSalary.

Department indicates the department in the company which the person belongs to, and ManagementSalary indicates whether that person is receiving a management position salary.

G = nx.read_gpickle('email_prediction.txt')

print(nx.info(G))
Name: 
Type: Graph
Number of nodes: 1005
Number of edges: 16706
Average degree:  33.2458
Part 2A - Salary Prediction
Using network G, identify the people in the network with missing values for the node attribute ManagementSalary and predict whether or not these individuals are receiving a management position salary.

To accomplish this, you will need to create a matrix of node features using networkx, train a sklearn classifier on nodes that have ManagementSalary data, and predict a probability of the node receiving a management salary for nodes where ManagementSalary is missing.

Your predictions will need to be given as the probability that the corresponding employee is receiving a management position salary.

The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).

Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.88 or higher will receive full points, and with an AUC of 0.82 or higher will pass (get 80% of the full points).

Using your trained classifier, return a series of length 252 with the data being the probability of receiving management salary, and the index being the node id.

Example:

    1       1.0
    2       0.0
    5       0.8
    8       1.0
        ...
    996     0.7
    1000    0.5
    1001    0.0
    Length: 252, dtype: float64
from sklearn.svm import SVC
from sklearn.neural_network import MLPClassifier
from sklearn.preprocessing import MinMaxScaler
def salary_predictions():
    def is_management(node):
        managementSalary = node[1]['ManagementSalary']
        if managementSalary == 0:
            return 0
        elif managementSalary == 1:
            return 1
        else:
            return None

    df = pd.DataFrame(index=G.nodes())
    df['clustering'] = pd.Series(nx.clustering(G))
    df['degree'] = pd.Series(G.degree())
    df['degree_centrality'] = pd.Series(nx.degree_centrality(G))
    df['closeness'] = pd.Series(nx.closeness_centrality(G, normalized=True))
    df['betweeness'] = pd.Series(nx.betweenness_centrality(G, normalized=True))
    df['pr'] = pd.Series(nx.pagerank(G))
    df['is_management'] = pd.Series([is_management(node) for node in G.nodes(data=True)])
    df_train = df[~pd.isnull(df['is_management'])]
    df_test = df[pd.isnull(df['is_management'])]
    features = ['clustering', 'degree', 'degree_centrality', 'closeness', 'betweeness', 'pr']
    X_train = df_train[features]
    Y_train = df_train['is_management']
    X_test = df_test[features]
    scaler = MinMaxScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)
    clf = MLPClassifier(hidden_layer_sizes = [10, 5], alpha = 5,
                       random_state = 0, solver='lbfgs', verbose=0)
    clf.fit(X_train_scaled, Y_train)
    test_proba = clf.predict_proba(X_test_scaled)[:, 1]
    return pd.Series(test_proba,X_test.index)
salary_predictions()
1       0.128439
2       0.586261
5       0.979859
8       0.133702
14      0.304625
18      0.208766
27      0.269586
30      0.336144
31      0.169191
34      0.143513
37      0.096221
40      0.195036
45      0.162267
54      0.249954
55      0.252905
60      0.176908
62      0.992842
65      0.551284
77      0.078478
79      0.132108
97      0.099812
101     0.057517
103     0.214342
108     0.122930
113     0.454489
122     0.044350
141     0.396296
142     0.863703
144     0.072049
145     0.419966
          ...   
913     0.045734
914     0.078520
915     0.002087
918     0.144304
923     0.035175
926     0.090079
931     0.055969
934     0.013933
939     0.011147
944     0.002353
945     0.039608
947     0.162715
950     0.098173
951     0.038313
953     0.027345
959     0.002922
962     0.002440
963     0.139886
968     0.110279
969     0.104672
974     0.095061
984     0.012668
987     0.110375
989     0.113364
991     0.116944
992     0.003956
994     0.003077
996     0.002429
1000    0.046944
1001    0.101407
Length: 252, dtype: float64
Part 2B - New Connections Prediction
For the last part of this assignment, you will predict future connections between employees of the network. The future connections information has been loaded into the variable future_connections. The index is a tuple indicating a pair of nodes that currently do not have a connection, and the Future Connection column indicates if an edge between those two nodes will exist in the future, where a value of 1.0 indicates a future connection.

future_connections = pd.read_csv('Future_Connections.csv', index_col=0, converters={0: eval})
future_connections.head(10)
Future Connection
(6, 840)	0.0
(4, 197)	0.0
(620, 979)	0.0
(519, 872)	0.0
(382, 423)	0.0
(97, 226)	1.0
(349, 905)	0.0
(429, 860)	0.0
(309, 989)	0.0
(468, 880)	0.0
Using network G and future_connections, identify the edges in future_connections with missing values and predict whether or not these edges will have a future connection.

To accomplish this, you will need to create a matrix of features for the edges found in future_connections using networkx, train a sklearn classifier on those edges in future_connections that have Future Connection data, and predict a probability of the edge being a future connection for those edges in future_connections where Future Connection is missing.

Your predictions will need to be given as the probability of the corresponding edge being a future connection.

The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).

Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.88 or higher will receive full points, and with an AUC of 0.82 or higher will pass (get 80% of the full points).

Using your trained classifier, return a series of length 122112 with the data being the probability of the edge being a future connection, and the index being the edge as represented by a tuple of nodes.

Example:

    (107, 348)    0.35
    (542, 751)    0.40
    (20, 426)     0.55
    (50, 989)     0.35
              ...
    (939, 940)    0.15
    (555, 905)    0.35
    (75, 101)     0.65
    Length: 122112, dtype: float64
def new_connections_predictions():
    
    from sklearn.ensemble import GradientBoostingClassifier
    
    future_connections['pref_attachment'] = [list(nx.preferential_attachment(G, [node_pair]))[0][2]
                                             for node_pair in future_connections.index]
    future_connections['comm_neighbors'] = [len(list(nx.common_neighbors(G, node_pair[0], node_pair[1]))) 
                                            for node_pair in future_connections.index]
    train_data = future_connections[~future_connections['Future Connection'].isnull()]
    test_data = future_connections[future_connections['Future Connection'].isnull()]
    clf = GradientBoostingClassifier()
    clf.fit(train_data[['pref_attachment','comm_neighbors']].values, train_data['Future Connection'].values)
    preds = clf.predict_proba(test_data[['pref_attachment','comm_neighbors']].values)[:,1]
    return pd.Series(preds, index=test_data.index)

new_connections_predictions()
(107, 348)    0.031823
(542, 751)    0.012931
(20, 426)     0.543026
(50, 989)     0.013104
(942, 986)    0.013103
(324, 857)    0.013104
(13, 710)     0.148865
(19, 271)     0.141496
(319, 878)    0.013104
(659, 707)    0.012887
(49, 843)     0.013104
(208, 893)    0.012887
(377, 469)    0.012221
(405, 999)    0.022630
(129, 740)    0.017730
(292, 618)    0.017926
(239, 689)    0.013104
(359, 373)    0.012696
(53, 523)     0.032456
(276, 984)    0.013104
(202, 997)    0.013104
(604, 619)    0.119968
(270, 911)    0.013104
(261, 481)    0.069337
(200, 450)    0.825813
(213, 634)    0.012931
(644, 735)    0.088258
(346, 553)    0.012970
(521, 738)    0.012503
(422, 953)    0.017730
                ...   
(672, 848)    0.013104
(28, 127)     0.979748
(202, 661)    0.012998
(54, 195)     0.998514
(295, 864)    0.013104
(814, 936)    0.012931
(839, 874)    0.013103
(139, 843)    0.013104
(461, 544)    0.013183
(68, 487)     0.013183
(622, 932)    0.012887
(504, 936)    0.017232
(479, 528)    0.013104
(186, 670)    0.013104
(90, 395)     0.126282
(329, 521)    0.029880
(127, 218)    0.165019
(463, 993)    0.013103
(123, 142)    0.781464
(764, 885)    0.013104
(144, 824)    0.013104
(742, 985)    0.013103
(506, 684)    0.012931
(505, 916)    0.013104
(149, 214)    0.937419
(165, 923)    0.013183
(673, 755)    0.013103
(939, 940)    0.013103
(555, 905)    0.012931
(75, 101)     0.017730
Length: 122112, dtype: float64

import networkx as nx
import matplotlib.pyplot as plt
from operator import itemgetter

%matplotlib inline
1. (1/1)
g = nx.Graph()
g.add_edges_from([('A', 'F'), ('F', 'E'), ('F', 'C'), ('A', 'C'), ('C', 'E'), 
                ('B', 'A'), ('B', 'C'), ('B', 'E'), ('B', 'D'), ('D', 'E'), ])

pos = nx.kamada_kawai_layout(g)
nx.draw_networkx(g, pos)
/home/f4119597/.local/lib/python3.6/site-packages/networkx/drawing/nx_pylab.py:579: MatplotlibDeprecationWarning: 
The iterable function was deprecated in Matplotlib 3.1 and will be removed in 3.3. Use np.iterable instead.
  if not cb.iterable(width):

degrees = dict(g.degree())
degree_sum = sum(dict(g.degree()).values())

degrees, degree_sum, len(g.nodes())
({'A': 3, 'F': 3, 'E': 4, 'C': 4, 'B': 4, 'D': 2}, 20, 6)
p_2 = 1/6
p_3 = 2/6

q1 = p_2 + p_3
q1
0.5
2. (0/1)
g = nx.DiGraph()
g.add_edges_from([('A', 'B'), ('A', 'C'), ('A', 'D'),
                    ('B', 'A'), ('B', 'C'), 
                    ('C', 'A'),
                    ('D', 'E'),
                    ('E', 'C')])

pos = nx.kamada_kawai_layout(g)
nx.draw_networkx(g, pos)
/home/f4119597/.local/lib/python3.6/site-packages/networkx/drawing/nx_pylab.py:676: MatplotlibDeprecationWarning: 
The iterable function was deprecated in Matplotlib 3.1 and will be removed in 3.3. Use np.iterable instead.
  if cb.iterable(node_size):  # many node sizes

nx.number_of_nodes(g), g.in_degree()
(5, InDegreeView({'A': 2, 'B': 1, 'C': 3, 'D': 1, 'E': 1}))
k = 1 is the most common degree

since our denominator is a fixed value nx.number_of_nodes(g)

3/nx.number_of_nodes(g) is the highest we can achieve

q2 = 1
q2
1
3. (1/1)
[x] If we draw a power law distribution...

[x] The Preferential Attachment Model generates...

4. (1/1)
[x] In the small-world model starting with k...

[x] Some small-world networks...

5. (1/1)
[x] Average local clustering will increase and average shortest path will decrease

6. (1/1)
g = nx.Graph()
g.add_edges_from(
    [
        ('C', 'G'), ('C', 'A'), ('A', 'D'), ('A', 'E'), ('G', 'D'), 
        ('D', 'E'), ('D', 'B'), ('E', 'H'), ('D', 'H'), ('H', 'F')
    ])

pos = nx.kamada_kawai_layout(g)
nx.draw_networkx(g, pos)
/home/f4119597/.local/lib/python3.6/site-packages/networkx/drawing/nx_pylab.py:579: MatplotlibDeprecationWarning: 
The iterable function was deprecated in Matplotlib 3.1 and will be removed in 3.3. Use np.iterable instead.
  if not cb.iterable(width):

comm_neig = sorted([(e[0], e[1], len(list(nx.common_neighbors(g, e[0], e[1])))) for e in nx.non_edges(g)],
                   key=itemgetter(2),
                   reverse=True)
pairs_H = [(node, h, common) for (node, h, common) in comm_neig if (node == 'H' or h == 'H')]
[('A', 'H', 2), ('H', 'G', 1), ('H', 'B', 1), ('H', 'C', 0)]
q6 = pairs_H[0][0]
q6
'A'
7. (1/1)
# Number of neighbors normalized by the total number of neighbors
jacc = list(nx.jaccard_coefficient(g))
# jacc
q7_ = [wanted for wanted in jacc if (wanted[0] == 'D' and wanted[1] == 'C')]
q7 = q7_[0][2]
q7
0.4
8. (1/1)
rai = list(nx.resource_allocation_index(g))
q3_ = [wanted for wanted in rai if (wanted[0] == 'D' and wanted[1] == 'C')]
q3 = q3_[0][2]
q3
0.8333333333333333
9. (1/1)
pref = sorted(list(nx.preferential_attachment(g)), key=itemgetter(2), reverse=True)
q9_ = [wanted for wanted in pref if (wanted[0] == 'D' and wanted[1] == 'C')]
q9 = q9_[0][2]
q9
10
10. (1/1)
g_comm = g.copy()
comm0 = 'A B C D G'.split()
comm1 = 'E F H'.split()

comm0, comm1
(['A', 'B', 'C', 'D', 'G'], ['E', 'F', 'H'])
for node in comm0:
    g_comm.node[node]['community'] = 0

for node in comm1:
    g_comm.node[node]['community'] = 1
# Acknowledge the community value
g_comm.node(data=True)
NodeDataView({'C': {'community': 0}, 'G': {'community': 0}, 'A': {'community': 0}, 'D': {'community': 0}, 'E': {'community': 1}, 'B': {'community': 0}, 'H': {'community': 1}, 'F': {'community': 1}})
cn_soun_hop = list(nx.cn_soundarajan_hopcroft(g_comm))
# cn_soun_hop
item1 = [wanted for wanted in cn_soun_hop if (wanted[0] == 'D' and wanted[1] == 'C')]
item1 # False
[('D', 'C', 4)]
item2 = [wanted for wanted in cn_soun_hop if (wanted[0] == 'A' and wanted[1] == 'G')]
item2 # True
[('A', 'G', 4)]
ra_sound_hop = list(nx.ra_index_soundarajan_hopcroft(g_comm))
# ra_sound_hop
item3 = [wanted for wanted in ra_sound_hop if (wanted[0] == 'E' and wanted[1] == 'F')]
item3 # False
[('E', 'F', 0.3333333333333333)]
item3 = [wanted for wanted in ra_sound_hop if (wanted[0] == 'A' and wanted[1] == 'G')]
item3 # True
[('A', 'G', 0.7)]
[x] The Commom ... of node 'A' and node 'G' is 4

[x] The Resource ... of node 'A' and node 'G' is 0.7

EOF
